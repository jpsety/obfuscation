// See README.md for license details.

package obfuscation

import firrtl.PrimOps.{Xor,Bits,Not,Cat,Head}
import firrtl.{CircuitState, LowForm, MALE, NodeKind, WRef}
import firrtl.ir._
import scala.collection.mutable.ListBuffer
import scala.util.Random
import chisel3._
import chisel3.util._
import chisel3.experimental.{ChiselAnnotation, RunFirrtlTransform, annotate}
import chisel3.internal.InstanceId
import chisel3.testers.BasicTester
import firrtl.{ChirrtlForm, CircuitForm, CircuitState, LowForm, Transform, Parser}
import firrtl.annotations.{SingleTargetAnnotation, ModuleName, Named}


/** FIRRTL annotation */
case class FSMLockAnnotation(target: Named, value: Map[String,Seq[Int]]) extends SingleTargetAnnotation[Named] {
	  def duplicate(n: Named): FSMLockAnnotation = this.copy(target = n)
}

/** ChiselAnnotation that corresponds to the above FIRRTL annotation */
case class FSMLockChiselAnnotation(target: InstanceId, value: Map[String,Seq[Int]]) extends ChiselAnnotation with RunFirrtlTransform {
	def toFirrtl: FSMLockAnnotation = FSMLockAnnotation(target.toNamed, value)
	def transformClass: Class[FSMLockTransform] = classOf[FSMLockTransform]
}

object FSMLock { // scalastyle:ignore object.name
	def apply(component: InstanceId, inputSeqs: Map[String,Seq[Int]]): Unit = {
  		val anno = FSMLockChiselAnnotation(component, inputSeqs)
		annotate(anno)
	}
}

/**
  * Adds Keyed logic to a low FIRRTL circuit
  */
class FSMLockTransform extends firrtl.Transform {

  	def inputForm: LowForm.type = LowForm
  	def outputForm: LowForm.type = LowForm

	//fix random seed
  	val rand = new Random(155)

	//variables passed through ast
	val stmtInds = ListBuffer[Int]()
	var stmtCount = 0
	var keyCount = 0
	var key = ""
	var keyLen = 0
	var moduleInputSeqs = scala.collection.mutable.Map[String, Map[String,Seq[Int]]]()
	var moduleInputWidths = scala.collection.mutable.Map[String, Map[String,Int]]()

  	def execute(state: CircuitState): CircuitState = {
   		val circuit = state.circuit

		//get annotations, contains input sequences and module InstanceId
		state.annotations.map {
			case FSMLockAnnotation(ModuleName(name,_), inputSeqs) =>
				//map module name to input seq
				moduleInputSeqs += (name -> inputSeqs)

				//get ports
				val ports = circuit.modules.find(_.name==name).orNull.ports

				//for all ports record width
				val inputNames = inputSeqs.keys
				val inputTypes = inputNames.map(x=>ports.find(_.name==x).orNull.tpe)
				val inputWidths = inputTypes.collect({case a: GroundType => a}).map(_.width).collect({case a: IntWidth => a}).map(_.width.toInt)
				moduleInputWidths += (name -> (inputNames zip inputWidths).toMap)
			case other => other
		}

		//generate FSMs
		//val fsmModules = moduleInputSeqs.keys map generateFSM

		//insert keys and connect FSMs
		//val modifiedModules = circuit.modules map keyModules

		//return keyed circuit
		//state.copy(circuit=circuit.copy(modules = fsmModules ++ modifiedModules))
		//println(fsmModules)
		//println(circuit.modules)
		//state.copy(circuit=circuit.copy(modules = circuit.modules ++ fsmModules))
		state
	}

	//count all stmts in the design
	//def keyModules(m: DefModule): DefModule = {
	//	m match {
	//		case mod @ firrtl.ir.Module(_,_,_,_) =>
	//			if (moduleKeys contains mod.name) {
	//				//get module key
	//				key = moduleKeys(mod.name)
	//				keyLen = key.length()
	//				println(key)

	//				//count statements in module
	//				stmtCount = 0
	//				mod mapStmt countStatements

	//				// randomly pick the statements to replace
	//				stmtInds.clear()
	//				stmtInds ++= rand.shuffle(List.range(0,stmtCount)).take(key.length()).sorted

	//				// add key port if the optimization has removed it
	//				val mod_io = if (mod.ports.exists(port => port.name == "io_obfKey") ) {
	//					println("io exists")
	//					mod 
	//				} else {
	//					println("io doesn't exist")
	//					new firrtl.ir.Module(mod.info, mod.name, mod.ports ++ Seq(Port(NoInfo,"io_obfKey",firrtl.ir.Input,UIntType(IntWidth(keyLen)))), mod.body)
	//				}

	//				//return modified module
	//				stmtCount = 0
	//				keyCount = 0
	//				mod_io mapStmt replaceStatements

	//			} else {mod}
	//		case other => other
	//	}
	//}

  	////count stmts
    //def countStatements(s: Statement): Statement = {
	//	s mapStmt countStatements
	//	s match {
	//	  case DefNode(_,_,_) =>
	//		stmtCount += 1
	//		s
	//	  case other => other
	//	}
  	//}

  	////replace selected stmts
    //def replaceStatements(s: Statement): Statement = {
    //	val s_mod = s mapStmt replaceStatements
    //    s_mod match {
    //    	case node @ DefNode(_,_,_) =>
    //        	if (stmtInds.contains(stmtCount)) {
	//				// get key value
	//			  	val keyBit = key.substring(key.length()-1-keyCount,keyLen-keyCount)

	//			  	// select key input to connect
	//			  	val key_io_ref = WRef("io_obfKey",UIntType(IntWidth(keyLen)),NodeKind,MALE)
	//			  	val key_bit_op = DoPrim(Bits,Seq(key_io_ref),Seq(keyCount,keyCount),UIntType(IntWidth(1)))
	//			  	val key_bit_node = DefNode(NoInfo,s"KEY_BIT_NODE_${keyCount}",key_bit_op)
	//			  	val key_bit_ref = WRef(s"KEY_BIT_NODE_${keyCount}",UIntType(IntWidth(1)),NodeKind,MALE)

	//			  	// change the name of the original node
	//			  	val orig_node = DefNode(node.info,node.name + "_mod",node.value)
	//			  	val orig_ref = WRef(node.name + "_mod",node.value.tpe,NodeKind,MALE)

	//			  	node.value.tpe match {
	//				  	case GroundType(IntWidth(width)) if width > 1 => 
	//						var cat_width = 2
	//						val cat_nodes = ListBuffer[DefNode]()
	//						var key_bit_cat_ref = key_bit_ref
	//						while (cat_width<=width) {
	//							val key_bit_cat_op = DoPrim(Cat,Seq(key_bit_ref, key_bit_cat_ref),Seq(),UIntType(IntWidth(cat_width)))
	//							val key_bit_cat_node = DefNode(NoInfo,s"KEY_BIT_CAT_NODE_${keyCount}_${cat_width}",key_bit_cat_op)
	//							cat_nodes += key_bit_cat_node
	//							key_bit_cat_ref = WRef(s"KEY_BIT_CAT_NODE_${keyCount}_${cat_width}",UIntType(IntWidth(cat_width)),NodeKind,MALE)
	//							cat_width += 1
	//						}
	//				  
	//					  	if (keyBit == "1") {
	//							// connect inv
	//							val not_op = DoPrim(Not,Seq(orig_ref),Seq(),node.value.tpe)
	//							val not_node = DefNode(NoInfo,node.name+"_inv",not_op)
	//							val not_ref = WRef(node.name+"_inv",node.value.tpe,NodeKind,MALE)

	//							// connect xor
	//							val xor_op = DoPrim(Xor,Seq(key_bit_cat_ref,not_ref),Seq(),node.value.tpe)
	//							val xor_node = DefNode(NoInfo,node.name,xor_op)

	//							//increment inds and return new block statement
	//							stmtCount += 1
	//							keyCount += 1
	//							Block(Seq(key_bit_node) ++ cat_nodes ++ Seq(orig_node,not_node,xor_node))
	//					  
	//					  	} else {
	//							// connect xor
	//							val xor_op = DoPrim(Xor,Seq(key_bit_cat_ref,orig_ref),Seq(),node.value.tpe)
	//							val xor_node = DefNode(NoInfo,node.name,xor_op)
	//						
	//							//increment inds and return new block statement
	//							stmtCount += 1
	//							keyCount += 1
	//							Block(Seq(key_bit_node) ++ cat_nodes ++ Seq(orig_node,xor_node))
	//					  	}

	//				  	case GroundType(IntWidth(width)) if width == 1 => 
	//					  	if (keyBit == "1") {
	//							// connect inv
	//							val not_op = DoPrim(Not,Seq(orig_ref),Seq(),node.value.tpe)
	//							val not_node = DefNode(NoInfo,node.name+"_inv",not_op)
	//							val not_ref = WRef(node.name+"_inv",node.value.tpe,NodeKind,MALE)

	//							// connect xor
	//							val xor_op = DoPrim(Xor,Seq(key_bit_ref,not_ref),Seq(),node.value.tpe)
	//							val xor_node = DefNode(NoInfo,node.name,xor_op)

	//							//increment inds and return new block statement
	//							stmtCount += 1
	//							keyCount += 1
	//							Block(Seq(key_bit_node,orig_node,not_node,xor_node))
	//					  
	//					  	} else {
	//							// connect xor
	//							val xor_op = DoPrim(Xor,Seq(key_bit_ref,orig_ref),Seq(),node.value.tpe)
	//							val xor_node = DefNode(NoInfo,node.name,xor_op)
	//						
	//							//increment inds and return new block statement
	//							stmtCount += 1
	//							keyCount += 1
	//							Block(Seq(key_bit_node,orig_node,xor_node))
	//					  	}

	//			  		case _ => s_mod
	//				}

    //        	} else {
    //          		stmtCount += 1
    //          		s_mod
    //        	}
    //      	case other => other
    //    }
	//}
/*
	def generateFSM(moduleName: String): DefModule = {
		val inputSeqs = moduleInputSeqs.get(moduleName).orNull
		val inputWidths = moduleInputWidths.get(moduleName).orNull
		println(inputSeqs)
		println(inputWidths)
		//val auxFSM_firrtl = chisel3.Driver.emit(() => new AuxFSM(inputSeqs,inputWidths))		
		//val auxFSM_firrtl = chisel3.Driver.emit(() => new GCD)		
		//val auxFSM_ast = Parser.parse(auxFSM_firrtl)
		val auxFSM_ast = chisel3.Driver.elaborate(() => new GCD)		
		println(auxFSM_ast)
		auxFSM_ast.circuit.modules.head
	}
	*/
}

class AuxFSM(
	inputSeqs: Map[String,Seq[Int]],
	inputWidths: Map[String,Int],
	nObfStates: Int = 10,
	maxFanout: Int = 4
) extends chisel3.Module {
	
	//get input, output, and state widths
	val inputWidth = inputWidths.values.foldLeft(0)(_+_)
	val nKeyStates = inputSeqs.get(inputSeqs.keys.head).orNull.length
	val nStates = nKeyStates + nObfStates
	val stateWidth = scala.math.ceil(scala.math.log(nStates)/scala.math.log(2)).toInt

	//io
	val io = IO(new Bundle {
		val in = chisel3.Input(UInt(inputWidth.W))
		val out = chisel3.Output(UInt(stateWidth.W))
	})

	//generate random state indicies
	val stateInds = Random.shuffle(0 to nStates-1).map(x=>x.U(stateWidth.W))
	def buildInd (t: (Seq[Int], Int)): Seq[chisel3.core.UInt] = t._1 map (x=>x.U(t._2.W))
	val inputInds = inputSeqs.values.zip(inputWidths.values).map(buildInd).map(chisel3.util.Cat(_))
	val obfStateInds = stateInds.take(nObfStates)
	val keyStateInds = stateInds.drop(nObfStates)
	val nextKeyStateInds = keyStateInds.drop(1)++keyStateInds.take(1)
	val nInputStates = scala.math.pow(2,inputWidth).toInt

	//FSM state
	val state = RegInit(obfStateInds(0))

	//randomly connect obfuscated states
	def GenObfStateMux(stateInd: chisel3.core.UInt) = {
		//determine fanout for this state
		val n_fanout = Random.nextInt(maxFanout)
		//select input states
		val inputs = List.fill(n_fanout)(Random.nextInt(nInputStates)).map(x=>x.U(inputWidth.W))
		//select their respective next states
		val next_states = Vector.fill(n_fanout)(obfStateInds(Random.nextInt(obfStateInds.length)))
		//return tuple of state and mux
		(stateInd, MuxLookup(io.in, stateInd, inputs zip next_states))
	}
	val obfStateMap = obfStateInds.map(GenObfStateMux)

	//connect key states in chain
	def GenKeyStateMux(t: (chisel3.core.UInt, chisel3.core.UInt, chisel3.core.UInt)) = {
		val inputInd = t._3
		val nextStateInd = t._2
		val stateInd = t._1
		//determine fanout for this state
		val n_fanout = Random.nextInt(maxFanout)
		//select input states
		val inputs = List.fill(n_fanout-1)(Random.nextInt(nInputStates)).map(x=>x.U(inputWidth.W)).filterNot(_==inputInd)++Seq(inputInd)
		//select their respective next states
		val next_states = List.fill(n_fanout-1)(obfStateInds(Random.nextInt(obfStateInds.length)))
		//return tuple of state and mux
		(stateInd, MuxLookup(io.in, stateInd, inputs zip next_states++Seq(nextStateInd)))
	}

	val keyStateMap = (keyStateInds, nextKeyStateInds, inputInds).zipped.toList.map(GenKeyStateMux)

	val nextState = MuxLookup(state, state, obfStateMap ++ keyStateMap)
	state := nextState

}

class GCD extends chisel3.Module {
  val io = IO(new Bundle {
  val value1        = chisel3.Input(UInt(16.W))
  val value2        = chisel3.Input(UInt(16.W))
  val loadingValues = chisel3.Input(Bool())
  val outputGCD     = chisel3.Output(UInt(16.W))
  val outputValid   = chisel3.Output(Bool())
  val key = chisel3.Input(UInt(4.W))
})

val x  = Reg(UInt())
val y  = Reg(UInt())

when(x > y) { x := x - y }
.otherwise { y := y - x }

when(io.loadingValues) {
	x := io.value1
	y := io.value2
}

io.outputGCD := x
io.outputValid := y === 0.U
}
